function generate_torque_coupler_function(modelName, block_name, comtype, num_tc, componentStruct)
    % Ensure the Simulink model is open
    open_system(modelName);

    % Check if the MATLAB Function block exists; if not, create it
    if ~bdIsLoaded(modelName)
        load_system(modelName);
    end

    if ~exist_block(block_name)
        add_block('simulink/User-Defined Functions/MATLAB Function', block_name);
    end

    % Generate the function script as a string
    funcScript = generateFunctionScript(modelName,comtype, num_tc, componentStruct);

    % Access the MATLABFunctionConfiguration object
    configObj = get_param(block_name, 'MATLABFunctionConfiguration');

    % Set the function script
    configObj.FunctionScript = funcScript;
end

function funcScript = generateFunctionScript(modelName,comtype, num_tc, componentStruct)
    % Generate the function signature based on num_tc
    outputs = {'w', 'dw', 't1', 't2', 't3', 't4', 't5'};
    outputList = strjoin(outputs(1:(2 + num_tc)), ', ');
    funcSignature = sprintf('function [%s] = torque_coupler_function(w_trans, dw_trans, t_trans)\n', outputList);
    % Initialize the function body
    funcBody = '';
    % Insert your function body code, converted to a string
    % Note: We need to replace line breaks with '\n' and handle any special characters

   motor_count = 0; 
   motor_Data = cell(0,1); 
   scales = [];  

   idx = 0;
   for i = 1:length(comtype) 
       if strcmp(comtype{i}, 'Electric motor 1') 
           idx = idx + 1;
           type_name = strrep(comtype(i), ' ', '');
           % component_name = [modelName '/' type_name '_' num2str(idx)];
           % component_name = strjoin(component_name, '');
           blockname = findBlock(componentStruct, i);
           component_name = [modelName '/' blockname];
           m_block_name = component_name; 
           [motor_Data{end+1}, scales(end+1)] = get_motor_scale_type(m_block_name);
       end
   end

    [omegas_m, torques_m, efficiencies_m, P_EM_max_m] = get_motor_data(motor_Data, scales);
    

    omegas_str = cell_to_str(omegas_m);
    torques_str = cell_to_str(torques_m);
    efficiencies_str = cell_to_str(efficiencies_m);

    funcBody = [
    '    coder.extrinsic(''set_param'');', newline, ...
    '    coder.extrinsic(''get_param'');', newline, ...
    '    coder.extrinsic(''regexp'');', newline, ...
    '    w = w_trans;', newline, ...
    '    dw = dw_trans;', newline, ...
    '    t1 = 0;', newline, ...
    '    t2 = 0;', newline, ...
    '    t3 = 0;', newline, ...
    '    t4 = 0;', newline, ...
    '    t5 = 0;', newline, ...
    '    omegas_m = ' omegas_str ';', newline, ...
    '    torques_m = ' torques_str ';', newline, ...
    '    efficiencies_m = ' efficiencies_str ';', newline, ...
    '', newline, ...
    '    %% Define step size and torque split array', newline, ...
    '    step_size = 5; %% Split step size in percentage', newline, ...
    '    torque_split_array = 0:step_size:100; %% Torque split options in %%', newline, ...
    '    total_torque_request = t_trans/0.98; % efficiency = 0.98', newline, ...
    '', newline, ...
    '    %% Generate all possible combinations of torque splits based on num_tc', newline, ...
    '    switch ' num2str(num_tc), newline, ...
    '        case 1', newline, ...
    '            all_combinations = torque_split_array'';', newline, ...
    '        case 2', newline, ...
    '            [A, B] = ndgrid(torque_split_array, torque_split_array);', newline, ...
    '            all_combinations = [A(:), B(:)];', newline, ...
    '        case 3', newline, ...
    '            [A, B, C] = ndgrid(torque_split_array, torque_split_array, torque_split_array);', newline, ...
    '            all_combinations = [A(:), B(:), C(:)];', newline, ...
    '        case 4', newline, ...
    '            [A, B, C, D] = ndgrid(torque_split_array, torque_split_array, torque_split_array, torque_split_array);', newline, ...
    '            all_combinations = [A(:), B(:), C(:), D(:)];', newline, ...
    '        case 5', newline, ...
    '            [A, B, C, D, E] = ndgrid(torque_split_array, torque_split_array, torque_split_array, torque_split_array, torque_split_array);', newline, ...
    '            all_combinations = [A(:), B(:), C(:), D(:), E(:)];', newline, ...
    '        otherwise', newline, ...
    '            %% Handle invalid num_tc value', newline, ...
    '            %% Since try-catch is not allowed, set outputs to zero and return', newline, ...
    '            t1 = 0; t2 = 0; t3 = 0; t4 = 0; t5 = 0;', newline, ...
    '            return;', newline, ...
    '    end', newline, ...
    '', newline, ...
    '    %% Now, all_combinations is a matrix where each row represents a unique combination', newline, ...
    '    total_splits = size(all_combinations, 1);', newline, ...
    '', newline, ...
    '    %% Initialize loss arrays for each combination', newline, ...
    '    loss_matrix = zeros(total_splits, 1);', newline, ...
    '    torque_splits = zeros(total_splits, ' num2str(num_tc) ');', newline, ...
    '', newline, ...
    '    %% Computation of losses for each split combination', newline, ...
    '    for idx = 1:total_splits', newline, ...
    '        torque_distribution = all_combinations(idx, :)'';', newline, ...
    '        %% Check for zero sum to avoid division by zero', newline, ...
    '        sum_distribution = sum(torque_distribution);', newline, ...
    '        if sum_distribution == 0', newline, ...
    '            continue; %% Skip this iteration as the distribution sum is zero', newline, ...
    '        end', newline, ...
    '        motor_torques = calculateMotorTorques(torque_distribution, total_torque_request, ' num2str(num_tc) ');', newline, ...
    '        total_loss = 0;', newline, ...
    '', newline, ...
    '        %% Compute total losses for all motors in the configuration', newline, ...
    '        valid_combination = true;', newline, ...
    '        for j = 1:' num2str(num_tc), newline, ...
    '            motor_torque = motor_torques(j);', newline, ...
    '            motor_speed = w_trans; %% Define motor speed logic if needed', newline, ...
    '', newline, ...
    '            %% Find motor efficiency based on torque and speed', newline, ...
    '            omegas = omegas_m{1};', newline, ...
    '            torques = torques_m{1};', newline, ...
    '            efficiencies = efficiencies_m{1};', newline, ...
    '            motor_efficiency = getMotorEfficiency(motor_torque, motor_speed, omegas, torques, efficiencies);', newline, ...
    '', newline, ...
    '            total_loss = total_loss + calculateLoss(motor_efficiency, motor_torque, w_trans);', newline, ...
    '        end', newline, ...
    '', newline, ...
    '        %% If combination is valid, store the total losses and torque splits', newline, ...
    '        if valid_combination', newline, ...
    '            loss_matrix(idx) = total_loss;', newline, ...
    '            torque_splits(idx, :) = motor_torques'';', newline, ...
    '        else', newline, ...
    '            %% Assign a high loss value to invalid combinations', newline, ...
    '            loss_matrix(idx) = Inf;', newline, ...
    '        end', newline, ...
    '    end', newline, ...
    '', newline, ...
    '    %% Find the index of the optimal split (with minimum loss)', newline, ...
    '    [~, optimal_index] = min(loss_matrix);', newline, ...
    '', newline, ...
    '    %% Output the optimal torque split', newline, ...
    '    optimal_torque_split = torque_splits(optimal_index, :);', newline, ...
    '', newline, ...
    '    %% Assign optimal torques to outputs', newline, ...
    '    t1 = 0; t2 = 0; t3 = 0; t4 = 0; t5 = 0; %% Initialize outputs', newline, ...
    '    if ' num2str(num_tc) ' >= 1, t1 = optimal_torque_split(1); end', newline, ...
    '    if ' num2str(num_tc) ' >= 2, t2 = optimal_torque_split(2); end', newline, ...
    '    if ' num2str(num_tc) ' >= 3, t3 = optimal_torque_split(3); end', newline, ...
    '    if ' num2str(num_tc) ' >= 4, t4 = optimal_torque_split(4); end', newline, ...
    '    if ' num2str(num_tc) ' >= 5, t5 = optimal_torque_split(5); end', newline, ...
    '', newline, ...
    '    %% Function Body End', newline, ...
    ];


    % Append subfunctions
    subFuncs = [
        '', newline, ...
        '    %% Subfunction to compute motor torque distribution based on split percentages', newline, ...
        '    function motor_torques = calculateMotorTorques(torque_distribution, total_torque_request, num_tc)', newline, ...
        '        %% Normalize the torque split distribution so that total is 100%%', newline, ...
        '        torque_distribution = torque_distribution / sum(torque_distribution);', newline, ...
        '', newline, ...
        '        %% Allocate torque for each motor', newline, ...
        '        motor_torques = torque_distribution * abs(total_torque_request);', newline, ...
        '        %% Ensure motor_torques have the same sign as total_torque_request', newline, ...
        '        motor_torques = motor_torques * sign(total_torque_request);', newline, ...
        '    end', newline, ...
        '', newline, ...
        '    %% Subfunction to calculate motor efficiency', newline, ...
        '    function efficiency = getMotorEfficiency(torque, speed, omegas_m, torques_m, efficiencies_m)', newline, ...
        '        %% Interpolate the motor efficiency based on torque and speed', newline, ...
        '        [~, torque_index] = min(abs(torques_m - torque)); %% Find closest torque index', newline, ...
        '        [~, speed_index] = min(abs(omegas_m - speed)); %% Find closest speed index', newline, ...
        '        if speed_index <= 0', newline, ...
        '            speed_index = 1;', newline, ...
        '            torque_index = 1;', newline, ...
        '        end', newline, ...
        '        %% Get the efficiency value from the map', newline, ...
        '        efficiency = efficiencies_m(speed_index, torque_index);', newline, ...
        '    end', newline, ...
        '', newline, ...
        '    %% Subfunction to calculate losses based on efficiency and torque', newline, ...
        '    function loss = calculateLoss(efficiency, torque, w_trans)', newline, ...
        '        %% Calculate power and loss', newline, ...
        '        if efficiency == 0', newline, ...
        '            loss = inf; %% Assign high loss for invalid efficiency', newline, ...
        '        else', newline, ...
        '            power_output = torque*w_trans; %% Placeholder for power calculation', newline, ...
        '            loss = abs(power_output * (1 - efficiency)); %% Simple loss formula', newline, ...
        '        end', newline, ...
        '    end', newline, ...
        ];

    % Combine signature, body, and subfunctions
    funcScript = [funcSignature, funcBody, subFuncs, 'end'];
end

function exists = exist_block(blockPath)
    % Check if a block exists in the model
    try
        get_param(blockPath, 'Handle');
        exists = true;
    catch
        exists = false;
    end
end

function output_string = cell_to_str(cell_array)
    output_string = '{';
    
    % Iterate through each element in the cell array
    for i = 1:length(cell_array)
        % Get the current element
        element = cell_array{i};
        
        % Convert the element to its string representation
        if ischar(element)
            % If it's a character array (string)
            str_rep = ['''' element ''''];
        elseif isnumeric(element) || islogical(element)
            % If it's numeric or logical, use num2str
            str_rep = mat2str(element);
        else
            % For other data types, handle as needed
            str_rep = '';  % Adjust based on your specific data types
        end
        % Append the string representation to the output string
        if i < numel(cell_array)
            output_string = [output_string str_rep ', '];
        else
            output_string = [output_string str_rep];
        end
        
    end
    output_string = [output_string '}'];
end
